%-*-coding: utf-8-*-

\chapter{Постановка задачи}

	В настоящее время, поиск \enquote{горячих} мест в программах завоевал достаточно широкую популярность. Многие компании, такие как Google, Yandex, Intel стараются писать приложения работающие как можно быстрее. Пользователи не готовы ждать, а улучшение производительности той или иной компоненты на долю процента, стоит огромных денег таким крупным игрокам на рынке. Особенно это важно компаниям работающих в сфере HFT \cite{hft}. В Google даже используют такую неформальную метрику \enquote{количество долларов за изменение в производительности кода} \cite{gwp}.

	В связи с чем возникает потребность в программе, которая бы помогала программистам искать узкие места в их приложениях. Сейчас существуют несколько решений и подходов к данной задачи. Все они не подошли по ряду причин, после чего было решено написать свой инструмент, который бы не имел недостатков, присущих в других решениях данной задачи.

\section{Термины и понятия}

	\textbf{Профилирование} - сбор характеристик работы программы, таких как время работы каждой функции данной программы. 
    
    \textbf{Профайлер} - программа которая занимается профилированием других приложений, предназначенная для сбора информации и визуализации полученных данных с целью поиска критических участков кода.
    
    \textbf{Профиль приложения} - информация о работе профилируемого приложения, собранная во время профилирования.
    
    \textbf{Стек вызовов} - упорядоченная последовательность адресов функций, которая привела программу в текущее состояние.
    
    \textbf{Сэмпл} - один из стеков вызовов полученный во время профилирования.
    
    \textbf{Сигнал} - UNIX сигнал, асинхронное уведомление, которое можно послать процессу или определенному потоку. Приводит к остановке работы текущей единицы исполнения и вызову обработчика сигнала.  
    
    \textbf{Символы} - символьная информация, хранящаяся в исполняемом файле. Например название функции находящейся по определенному адресу.
        
    \textbf{Деманглирование} - декодирование имени функции. 
    
    \textbf{Разрешение символов} - преобразование адресов программы в закодированные названия функций, которые после необходимо деманглировать.
    
    
    \textbf{Стековый кадр} - часть данных, которая сохраняется перед началом исполнения кода функции, например, старые значения регистров, чтобы не испортить их предыдущие значения.
        
    \textbf{tid} - идентификатор потока исполнения.
    
    \textbf{pid} - идентификатор процесса.


\section{Обзор существующих решений}

	На данный момент написано множество различных профайлеров. По своему типу они бывают:
    \begin{itemize}
    	\item На основе событий
        \item Статистические или сэмплирующие
        \item Инструментирующие код
    \end{itemize}
    
    \textbf{На основе событий} профайлеры обычно реагирует на происходящие изменения и в этот момент записывают соответствующую информацию. Например на вызов функции или выход из нее. 
    
    \textbf{Статистические или сэмплирующие} - собирают информацию о приложении через определенные интервалы времени, приостанавливая его работу на короткий промежуток времени. Зачастую такие профайлеры менее точны, но этого достаточно, чтобы обнаружить проблемные участки. Такие инструменты почти не замедляют работающее приложение. Также, зачастую, они не требуют наличия исходных кодов и перекомпиляции приложения, что значительно упрощают работу с ними.
    
    \textbf{Инструментирующие код} - такие профайлеры меняют исходный код программы, вставляя в нужном месте вызов своих функций для подсчета информации. Они зачастую привносят очень большие накладные расходы приложению. Ими сложнее воспользоваться, когда хочется профилировать уже скомпилированное приложение.
    
    Далее будут рассмотрены доступные в свободном доступе профайлеры под систему Linux:
    \begin{itemize}
    	\item gprof \cite{gprof}
        \item google-perftools  \cite{gperf}
        \item perf \cite{perf}
        \item OProfile \cite{oprofile}
        \item callgrind \cite{valgrind}
    \end{itemize}
    
    \textbf{gprof} - смесь инструментирующего профайлера и сэмплирующего. Инструментация кода происходит автоматически во время компиляции, в компилияторе \verb|gcc|, например, можно включить его опцией \verb|-pg|. Перед входом в каждую функцию вставляется вызов функции \verb|mcount|. Сэмплированные данные вместе с дополнительной информацией сохраняются в файл \verb|gmon.out| и могут быть проанализированы при помощи утилиты \verb|gprof|.
    
    У него присутствует множество проблем из-за которых возникают трудности в использовании. Инструментируя код, потенциально можно сильно замедлить приложение. Накладные рассходы на CPU могут быть 30\%-260\%. Возникает это, если маленькие функции, которые очень часто вызываются будут инструментированы, что может быть дольше чем выполнение самой функции. Во вторых он не умеет работать с не статической сборкой приложения. В связи с чем не отображается информация о времени работы функций из библиотек загруженных динамически, из-за чего происходит потеря важной информации. Также он не умеет показывать информацию по каждому потоку в отдельности, что очень важно при поиске узких мест.  А также нельзя смотреть состояние процесса на определенный момент времени.
    
    \textbf{google-perftools} - инструмент разработанный компанией Google для их внутренних нужд. Он отлично работает с приложениями скомпилированными не статически. Он является сэмплирующим, настраивает интервальный  системный таймер, по истечении которого процесс прерывается сигналом SIGPROF. После они разворачивают стек при помощи библиотеки libunwind. Так как это происходит в рамках того же процесса которое профилируется, может возникнуть следующиая ситуация. Если программа бросает исключение, во время раскрутки стека вызывается функция \verb|_Unwind_Find_FDE| библиотеки libunwind. Внутри себя она берет блокировку, если они прервали приложение в этот момент, то в обработчике сигнала они тоже вызывают эту функцию и попадают в deadlock. В итоге этот профайлер мы не можем запускать на реально работающих приложениях использующих исключения, из-за потенциальной возможности сломать его.
    
    \textbf{perf и OProfile} - одни из самых часто используемых инструментов на Linux \cite{ibm}. Они умеют подключаться к приложению по pid. Собирать с него информацию, привносят незаметные накладные расходы на приложение. Но также не подходят из-за невозможности видеть состояние системы в определенные промежутки времени в визуализаторах, отображающих собранную информациюй. Хотя временные метки могут быть записаны в файл.
    
    \textbf{Callgrind} - этот инструмент является частью проекта Valgrind \cite{valgrind}. Он запускается в структуре Valgrind. При использовании Callgrind профилируемый код трансформируется в промежуточный язык и запускается на виртуальном процессоре имитируемом Valgrind. Что влечет за собой большие накладные расходы, но качество профиля очень хорошее. Замедление, работающей программы, может варьироваться в пределах от 10 до 50 раз. Из-за больших накладных расходов мы не можем использовать его на реальных системах.
    
\section{Уточненные требования к работе}
	Актуальность создания своего инструмента была показана ранее. От нового ожидается увидеть возможность собирать стек вызовов не испортив профилируемое приложение. Например \verb|gperftools| может привести во взаимную блокировку профилируемое приложение во время сбора информации \cite{deadlock_gperf}, необходимо избежать таких ситуаций. Сбор в реальном времени не должен сильно замедлять работоспособность программы. Профайлер должен уметь собирать информацию со всех потоков, не вынуждая совершать пользователей каких-либо дополнительных усилий. Вся информация собранная в процессе профилирования должна быть аннотирована временными метками, для возможности дальнейшего исследования. Также профайлер должен сохранить информацию о текущем адресном пространстве приложения, для восстановления символов. Собранная информация на одной машине должна без проблем быть прочитана и восстановлена на другой. 
    
    Также должен  быть создан инструмент для визуализации собранных данных, с помощью которого можно было бы искать узкие места в программах. Должна присутствовать возможность смотреть состояние профилированной программы в определенные моменты времени.

\chapterconclusion
	В данной главе была поставлена задача. Приведены основные термины и понятие используемые в этой работе. Также было рассказано о способах решения данной проблемы и существующие решения. Как видно ни одно из них не умеет решать поставленной задачи. В связи с чем возникает потребность в написании собственного инструмента.
    
